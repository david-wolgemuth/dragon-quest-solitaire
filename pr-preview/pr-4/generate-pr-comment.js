#!/usr/bin/env node

/**
 * Generates markdown PR comment with dynamically discovered fixture URLs
 *
 * Usage:
 *   node generate-pr-comment.js <pr-number> <commit-sha>
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { serializeGameState } from './url-state.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const args = process.argv.slice(2);
const prNumber = args[0];
const commitSha = args[1];

if (!prNumber || !commitSha) {
  console.error('Usage: node generate-pr-comment.js <pr-number> <commit-sha>');
  process.exit(1);
}

// Load all fixtures
const fixturesDir = path.join(__dirname, 'test', 'fixtures');
const fixtureFiles = fs.readdirSync(fixturesDir)
  .filter(file => file.endsWith('.json'))
  .sort();

// Emoji mapping for different fixture types
const getEmoji = (name) => {
  if (name.includes('early')) return 'üå±';
  if (name.includes('mid')) return 'üéØ';
  if (name.includes('late')) return '‚öîÔ∏è';
  if (name.includes('deterministic')) return 'üîÅ';
  if (name.includes('verify')) return '‚úÖ';
  return 'üéÆ';
};

// Generate fixture links
const fixtureLinks = [];

for (const file of fixtureFiles) {
  const fixturePath = path.join(fixturesDir, file);
  const fixtureData = JSON.parse(fs.readFileSync(fixturePath, 'utf8'));

  const { name, description, metadata = {}, state } = fixtureData;

  // Reconstruct game object for serialization
  const matrixRows = state.matrixRows ||
    Math.max(...state.dungeonMatrix.map(c => c.row), 0) + 1;
  const matrixCols = state.matrixCols ||
    Math.max(...state.dungeonMatrix.map(c => c.col), 0) + 1;

  const mockGame = {
    health: state.health,
    inventory: state.inventory,
    gems: state.gems,
    fate: state.fate,
    dungeon: {
      stock: state.dungeonStock,
      matrix: Array(matrixRows).fill(null).map(() =>
        Array(matrixCols).fill(null).map(() => ({
          card: null,
          cardFaceDown: false
        }))
      )
    }
  };

  // Place cards from dungeonMatrix
  for (const cellData of state.dungeonMatrix) {
    mockGame.dungeon.matrix[cellData.row][cellData.col] = {
      card: cellData.card,
      cardFaceDown: cellData.cardFaceDown
    };
  }

  const stateString = serializeGameState(mockGame);
  const baseUrl = `https://david-wolgemuth.github.io/dragon-quest-solitaire/pr-preview/pr-${prNumber}`;
  const fullUrl = `${baseUrl}/?${stateString}`;

  const emoji = getEmoji(name);
  fixtureLinks.push(`${emoji} [**${description}**](${fullUrl})`);
}

// Generate the comment markdown
const comment = `üöÄ **Preview deployed!**

### Base Preview
üéÆ [**Base Game**](https://david-wolgemuth.github.io/dragon-quest-solitaire/pr-preview/pr-${prNumber}/) - Fresh start, no URL state

### Test Scenarios with URL State
${fixtureLinks.join('\n')}

<details>
<summary>‚ÑπÔ∏è About URL State</summary>

Each scenario link includes the game state in the URL. This allows you to:
- Test specific game situations reproducibly
- Share exact game states for debugging
- QA specific scenarios without manual setup

All scenarios use test fixtures generated from actual gameplay with deterministic seeds.
The fixtures are automatically generated by integration tests (\`npm test\`).
</details>

*Updated for commit ${commitSha}*`;

console.log(comment);
